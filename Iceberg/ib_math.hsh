// Copyright (c) 2019 Cranberry King; 2025 Snowed In Studios Inc.

#ifndef IB_MATH_HSH
#define IB_MATH_HSH

static float const Pi = 3.14159265358979323846264338327f;
static float const RcpPi = 1.0f / Pi;

float4 bilinear(float4 r0, float4 r1, float4 r2, float4 r3, float2 t)
{
	float4 l0 = lerp(r0, r1, t.x);
	float4 l1 = lerp(r2, r3, t.x);
	return lerp(l0, l1, t.y);
}

float bilateralDepthWeight(float2 sourceTexel, float2 sampleTexel, float sourceDepth, float sampleDepth, float texelSigma, float depthSigma)
{
	float deltaDepth = sourceDepth - sampleDepth;
	float2 texelOffset = sourceTexel - sampleTexel;
	return exp(-dot(texelOffset,texelOffset)/(2.0f * texelSigma*texelSigma) - deltaDepth*deltaDepth / (2.0f * depthSigma*depthSigma));
}

// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
float radicalInverse_VdC(uint bits) {

	// This is simply reversebits
	//bits = (bits << 16u) | (bits >> 16u);
	//bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
	//bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
	//bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
	//bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
	return float(reversebits(bits)) * 2.3283064365386963e-10; // / 0x100000000
}

float2 hammersley2d(uint i, uint N) {
    return float2(float(i)/float(N), radicalInverse_VdC(i));
}

float3 sphereSampleUniform(float u, float v) {
	float phi = v * 2.0f * Pi;
	float cosTheta = 1.0f - u * 2.0f;
	float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
	return float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

float2 dirToSpherical(float3 view)
{
	float theta = acos(view.z);
	float phi = atan2(view.y, view.x);

	return float2(phi, theta);
}

bool sphereRayIntersect(float3 o, float3 v, float r, out float2 t)
{
	float a=1.0f;//dot(v,v); v is expected to be normalized
	float b=2.0f*dot(v,o);
	float c=dot(o,o)-r*r;
	float d=b*b-4.0f*a*c;
    
	t=float2((-b-sqrt(d))/(2.0f*a), (-b+sqrt(d))/(2.0f*a));
	return d>=0.0f;
}

float random( float2 p )
{
    float2 K1 = float2(
        23.14069263277926, // e^pi (Gelfond's constant)
		2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)
    );
    return frac( cos( dot(p,K1) ) * 12345.6789 );
}

#endif // IB_MATH_HSH
